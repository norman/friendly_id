= FriendlyId

FriendlyId is a comprehensive slugging and permalink plugin for Ruby on Rails.
It allows you to create pretty URL's, and work with human-friendly strings as
if they were numeric ids for ActiveRecord models.

The main use we intend friendly_id for is in URL's, so your application can
have URL's like:

  http://example.com/states/washington

rather than

  http://example.com/states/4323454

You can find a {FriendlyId tutorial here}[http://randomba.org/posts/friendly_id-tutorial].

== Why?

* Text-based id's look better
* They make URL's easier to remember.
* They give no hint about the number of records in your database.
* They are better for search engine optimization.

=== But...

* They can change, breaking your URL's.
* They can have invalid URL characters, breaking your links in some browsers.
* It can be tricky to ensure they're always unique.

FriendlyId tries to offer you the all the advantages, and avoid or soften the
potential impact of the disadvantages.

== Typical Uses

=== User names ("non-slugged" models)

Usually users have unique user names stored in a column with a unique
constraint or index. In this case, all you need to do is add this to your
model:

  has_friendly_id :login

and you can then write code like this:

  @member = Member.find("joe")   # the old Member.find(1) still works, too.
  @member.to_param               # returns "joe"
  redirect_to @member            # The URL would be /members/joe

=== Blog posts ("slugged" models)

Blog posts generally have titles which are distinctive but not necessarily
unique. In this and similar cases, FriendlyId provides a Slug model separate
from your Post model. The Slug model handles duplicate friendly_ids, as well
as versioning.

Your model code would look something like this:

  has_friendly_id :title, :use_slug => true

and you can then write code like this:

  @post = Post.find("new-version-released")  # Post.find(1) still works, too
  @post.to_param                             # returns "new-version-released"
  redirect_to @post                          # The URL would be /posts/new-version-released

Now in your controllers, if you want to prevent people from accessing your
models by numeric id, you can detect whether they were found by the
friendly_id:

  @post.find(params[:id])
  raise "some error" if !@post.found_using_friendly_id?

or, you can 301 redirect if the model was found by the numeric id if you don't
care about numeric access, but want the SEO value of the friendly_id:

  @post.find(params[:id])
  redirect_to @post, :status => 301 if @post.has_better_id?

The "has_better_id?" method returns true if the model was found with the
numeric id, or with an outdated slug.

== Extra Features

=== Slug Versioning

FriendlyId will record changes to slugs so that you can tell when the model
is found with an older slug. This can be useful if you want to do a 301
redirect to your updated URL.

  def find_record_using_friendly_id
    @post = Post.find(params[:id])
    redirect_to @post, :status => :moved_permanently if @post.has_better_id?
  end

=== Non-unique Slug Names

FriendlyId will append a arbitrary number to the end of the id to keep it
unique if necessary:

  /posts/new-version-released
  /posts/new-version-released--2
  /posts/new-version-released--3
  ...
  etc.

Note that the number is preceeded by two dashes to distinguish it from the
rest of the slug. This is important to enable having slugs like:

  /cars/peugeot-206
  /cars/peugeot-206--2

This is somewhat ugly, but you can change the "--" for another character or
sequence of characters if you wish.

=== Scoped Slugs

FriendlyId can generate unique slugs within a given scope. For example:

  class Restaurant < ActiveRecord::Base
    belongs_to :city
    has_friendly_id :name, :use_slug => true, :scope => :city
  end

  class City < ActiveRecord::Base
    has_many :restaurants
    has_friendly_id :name, :use_slug => true
  end

  http://example.org/cities/seattle/restaurants/joes-diner
  http://example.org/cities/chicago/restaurants/joes-diner

  Restaurant.find("joes-diner", :scope => "seattle") # returns 1 record
  Restaurant.find("joes-diner", :scope => "chicago") # returns 1 record
  Restaurant.find("joes-diner") # returns both records


The value for the :scope key in your model can be a custom method you define,
or the name of a relation. If it's the name of a relation, then the scope's
text value will be the result of calling <code>to_param</code> on the related
model record. In the example above, the city model also uses FriendlyId and so
its <code>to_param</code> method returns its friendly_id: chicago or seattle.

This feature is new in FriendlyId 2 and should be considered of experimental
quality. Please don't use this for code that needs to run on the Space
Shuttle.

=== Text Normalization

FriendlyId's slugging can strip diacritics from Western European characters,
for example conveting "ñøîéçü" to "noiecu."

  has_friendly_id :title, :use_slug => true, :strip_diacritics => true

If you are not using slugs, you'll have to do this manually for whatever value
you're using as the friendly_id.

Note that this ovbiously won't work for Chinese, Arabic, Russian, Hebrew,
Thai, etc. because it will pretty much blow away all the chracters... it's
only for languages that use some variant of the Roman alphabet, like English
or Polish.

== Getting it

FriendlyId is installed as a Ruby Gem:

  gem install friendly-id

Alternatively, you can install it as a Rails plugin, though this is
discouraged:

./script/plugin install git://github.com/norman/friendly_id.git

== Setting it up

FriendlyId currently works with Rails 2.1.0 and higher. Older versions of
FriendlyId that work with Rails 1.2.x and Rails 2.0.x are available as tags on
Github.

Here's how to set it up:

  sudo gem install friendly-id
  cd my_app
  script/generate friendly_id
  rake db:migrate

Now add the following 2 lines to bottom of your Rakefile:

  require 'friendly_id'
  require 'tasks/friendly_id'

Now add some code to your models:

  class Post < ActiveRecord::Base
    has_friendly_id :title, :use_slug => true
  end

If you are using slugs, you can use a Rake task to generate slugs for your
existing records:

friendly_id:make_slugs MODEL=MyModelName

If you eventually want to expire old slugs every so often, or perhaps every
day via cron, you can do:

rake:friendly_id:remove_old_slugs

The default is to remove dead slugs older than 45 days, but is configurable:

rake:friendly_id:remove_old_slugs MODEL=MyModelName DAYS=60

Note that having to explicitly add the friendly_id rake tasks to the Rakefile
is a pain in the ass. This is because Rails does not have any provisions for
accessing rake tasks from Gem plugins - even though it can do this for
generators. There is {a ticket sitting waiting on
Lighthouse}[http://rails.lighthouseapp.com/projects/8994/tickets/59] since
April of 2008 asking the Rails team to fix this, but it appears no agreement
can be reached on how to proceed and so we still don't have this functionality
as of December 2008.

== Hacking FriendlyId:

FriendlyId is {hosted on Github}[git://github.com/norman/friendly_id.git], and
we love pull requests. :-)

== Bugs:

Please report them on Lighthouse[http://randomba.lighthouseapp.com/projects/14675-friendly_id].

== Credits:

FriendlyId was created by {Norman Clarke}[mailto:norman@randomba.org],
{Adrian Mugnolo}[mailto:adrian@randomba.org], and {Emilio Tagua}[mailto:miloops@gmail.com].

Copyright (c) 2008 Norman Clarke, Adrian Mugnolo and Emilio Tagua, released
under the MIT license.